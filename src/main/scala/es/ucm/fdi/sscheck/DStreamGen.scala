package es.ucm.fdi.sscheck

import org.scalacheck.Gen
import org.scalacheck.Arbitrary
import org.scalacheck.Arbitrary.arbitrary
import BatchGen.now

/**
 * All the temporal generators defined in this object are sized generators, but the size parameters
 * only affects the number of batches in the output DStream, not the size of the batches. 
 * The size of the batches can be changed by using Gen.resize in the definition of the batch
 * generator that is passed to these HO generators
 * 
 * On the other hand for generators of arbitrary DStreams like Gen.resize(5, arbitrary[DStream[Int]])
 * Gen.resize has effect, both in the number of batches and in the size of the batches, as those
 * arbitrary instances are based on arbitrary for lists
 * 
 *  TODO  That should be tested
  // by using Gen.resize(5, TLGen.always(Batch(List(0, 1)))) (constant batch size)
  // and then in Gen.resize(3, TLGen.always(BatchGen.ofNtoM(1, 5, Gen.choose(0, 3))))
  // the point is that we always have 3 batches, but Gen.resize doesn't affect the batch
  // size but only the number of batches
  // 
 *
 * TODO tests for all of this
 * TODO make some example with the assertions from expected and observed for 
 * Seq[Seq[A]], use map on the generated DStreams and batch as those are Seq, 
 * check if comprehensions work or we have to implement something 
 * */
object DStreamGen {
  def apply[A](dsg : Gen[DStream[A]]) : DStreamGen[A] = new DStreamGen(dsg)
  implicit def genDStream2DStreamGen[A](dsg : Gen[DStream[A]]) : DStreamGen[A] = DStreamGen(dsg)
    
  implicit def dstreamGen2batchSeqGen[A](gs : Gen[DStream[A]]) : Gen[Seq[Batch[A]]] = gs.map(_.toSeq)
  implicit def batchSeqGen2dstreamGen[A](gs : Gen[Seq[Batch[A]]]) : Gen[DStream[A]] = gs.map(DStream(_:_*))
    
  /** Arbitrary generator for DStream. Only works if an Arbitrary for Batch is also present. 
   *  Note this hasn't been automatically derived from Buildables.buildableDStreamFromBatch
   *  for the same reason Gen.buildableOf has to be used with DStream instead of Gen.containerOf
   * */
  implicit def arbDStream[A](implicit arbBatch : Arbitrary[Batch[A]]) : Arbitrary[DStream[A]] = 
    Arbitrary(DStreamGen.of(arbitrary[Batch[A]]))
  
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def of[T](bg : => Gen[Batch[T]]) : Gen[DStream[T]] = {
    import Buildables.buildableDStreamFromBatch
    Gen.buildableOf[DStream[T], Batch[T]](bg)
  }
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def ofN[T](n : Int, bg : Gen[Batch[T]]) : Gen[DStream[T]] = {
    import Buildables.buildableDStreamFromBatch
    Gen.buildableOfN[DStream[T], Batch[T]](n, bg)
  }
  /** @returns a generator of DStream that generates its batches from bg
   * */
  def ofNtoM[T](n : Int, m : Int, bg : Gen[Batch[T]]) : Gen[DStream[T]] = {
    import Buildables.buildableDStreamFromBatch
    UtilsGen.buildableOfNtoM[DStream[T], Batch[T]](n, m, bg)
  }
  
  /** @return a generator for the batch-by-batch concatenation of the dstreams 
  *  generated by gs1 and gs2. Note we fill either dstreams with empty batches 
  *  This implies dstreams are implicitly treated as they where infinitely extended 
  *  with empty batches  
  */
  def dstreamUnion[A](gs1 : Gen[DStream[A]], gs2 : Gen[DStream[A]]) : Gen[DStream[A]] = {
    for {
      xs1 <- gs1
      xs2 <- gs2
    } yield xs1 #+ xs2 
  }
  
  /** @return a dstream generator that has an empty batch followed by the batches
   *  from dsg
   * */
  def next[A](dsg : Gen[DStream[A]]) : Gen[DStream[A]] = {
    now(Batch.empty : Batch[A]) ++ dsg 
  }
  
  /**
   * Example:
   * 
  Gen.resize(10,
  	until(
  		DStreamGen.ofN(1, BatchGen.ofN(2, Gen.choose(0, 10))),
  		DStreamGen.ofN(1, BatchGen.ofN(2, Gen.choose(10, 20))))
  	).sample   //> res42: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(5, 9), 
               //| Batch(0, 0), Batch(8, 3), Batch(6, 10), Batch(6, 1), Batch(1, 3), Batch(13,
               //|  17))) 
   * 
   * */
  def until[A](dsg1 : Gen[DStream[A]], dsg2 : Gen[DStream[A]]) : Gen[DStream[A]] = 
    Gen.sized { size =>
      val prefixGen : Gen[DStream[A]] = 
        UtilsGen. containerOfNtoM[List, DStream[A]](0, size -1, dsg1)
                . map(_.flatten) 
      prefixGen ++ dsg2
    }
  
  def eventually[A](bg : Gen[DStream[A]]) : Gen[DStream[A]] =
    Gen.sized { size =>
      DStreamGen.ofNtoM(0, size -1, Batch.empty : Batch[A]) ++ bg 
    }
  
  /**
   * Example: 
   * 
   val alwaysS2 =
    always(
      TLGen.until(Batch(0), Batch(1))
    )            
                 
   Gen.resize(6, alwaysS2).sample        //> res38: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
                                         //| ch(0, 0), Batch(1, 1, 1), Batch(0), Batch(1, 1), Batch(1)))
   Gen.resize(10, alwaysS2).sample       //> res39: Option[es.ucm.fdi.sscheck.DStream[Int]] = Some(DStream(Batch(0), Bat
                                         //| ch(0, 0), Batch(0, 0, 1), Batch(0, 0, 0), Batch(0, 1, 0, 0), Batch(0, 0, 1,
                                         //|  0), Batch(0, 0, 0, 0), Batch(1, 0, 0, 0, 0), Batch(0, 1, 1, 0, 0), Batch(1
                                         //| , 1, 1, 1)))
   * */
  def always[A](dsg : Gen[DStream[A]]) : Gen[DStream[A]] =
    Gen.sized { size =>
      if (size <= 0)
        Gen.const(DStream.empty)
      else 
        /* note this is not the same as laterDs <- Gen.resize(size - 1, alwaysS(dsg))
         * and then yield nowDs ++ laterDs, because this way a DStream from dsg is
         * started at each moment 
         */
        for {
          nowDs <- dsg
          // laterDs <- Gen.resize(size - 1, alwaysS(dsg))
          // FIXME re-think and write test
          // laterDs <- Gen.resize(size - 1, nextS(alwaysS(dsg)))
          laterDs <- next(Gen.resize(size - 1, always(dsg)))
         } yield nowDs #+ laterDs
    }
  
  /** 
   *  Generator for the weak version of LTL release operator: either bg2
   *  happens forever, or it happens until bg1 happens, including the
   *  moment when bg1 happens  
   * */
  def release[A](dsg1 : Gen[DStream[A]], dsg2 : Gen[DStream[A]]) : Gen[DStream[A]] =
    Gen.sized { size =>
      for {
        prefix <- UtilsGen. containerOfNtoM[List, DStream[A]](0, size -2, dsg2)
                . map(_.flatten)
        isReleased <- arbitrary[Boolean]
        tail <- if (isReleased) (dsg1 + dsg2) else dsg2       
      } yield prefix ++ tail
    }
} 

class DStreamGen[A](self : Gen[DStream[A]]) {
  import DStreamGen._
  /** Returns the generator that results from concatenating the sequences
   *  generated by the generator wrapped by this, and other 
   * */
  def ++(other : Gen[DStream[A]]) : Gen[DStream[A]] = UtilsGen.concSeq(self, other)
  
  /** @return a generator for the batch-by-batch concatenation of the dstreams 
  * generated by the generator wrapped by this, and other 
  * Note we fill either dstreams with empty batches. This implies dstreams 
  * are implicitly treated as they where infinitely extended with empty batches  
  */
  def +(other : Gen[DStream[A]]) : Gen[DStream[A]] = dstreamUnion(self, other)
}