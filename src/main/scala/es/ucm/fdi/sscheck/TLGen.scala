package es.ucm.fdi.sscheck

import org.scalacheck.Gen
import org.scalacheck.Gen.sized
// import Buildables._
// import UtilsGen.{containerOfNtoM,concSeq}

// implicits to DStreamGen
import DStreamGen._
object TLGen {  
  /** @return a dstream generator with exactly bg as the only batch
  * */
  def now[A](bg : Gen[Batch[A]]) : Gen[DStream[A]] = {
    for {
      batch <- bg
    } yield DStream(batches = List(batch))
  } 
  
  /** @return a dstream generator that has exactly two batches, the first one
   *  is emptyBatch, and the second one is bg  
   * */
  def nextB[A](bg : Gen[Batch[A]]) : Gen[DStream[A]] = {
    next(now(bg))
  } 
  
  /** @return a dstream generator that has an empty batch followed by the batches
   *  from dsg
   * */
  def next[A](dsg : Gen[DStream[A]]) : Gen[DStream[A]] = {
    now(Batch.empty : Batch[A]) ++ dsg 
  }
  
  /**
   * @return a generator of DStream that repeats batches generated by gb1 until 
   * a batch generated by bg2 is produced
   * 
   * Note bg2 always occurs eventually, so this is not a weak until. When bg2 occours
   * then the generated DStream finishes 
   * This generator is exclusive in the sense that when bg2 finally happens then bg1 
   * doesn't occur. 
   * 
   * Example: Gen.resize(10, TLGen.untilB(BatchGen.ofN(3, 0), BatchGen.ofN(2, 1))). sample
   * */
  def untilB[A](bg1 : Gen[Batch[A]], bg2 : Gen[Batch[A]]) : Gen[DStream[A]] =
    Gen.sized { size =>
      for {
        // i = how many times do are we repeating bg1 
        i <- Gen.choose(0, size - 1)
        // ok as DStreamGen.ofN works ok for n < 0
        ds1 <- DStreamGen.ofN(i, bg1)
        ds2 <- now(bg2)
      } yield ds1 ++ ds2
  }
}