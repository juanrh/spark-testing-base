package es.ucm.fdi.sscheck

import org.scalacheck.{Properties, Gen}
import org.scalacheck.Arbitrary.arbitrary
import org.scalacheck.Prop.{forAll, exists, AnyOperators, collect}
import org.scalatest._
import org.scalatest.Matchers._
import org.scalatest.prop.PropertyChecks._
import org.scalatest.Inspectors.{forAll => testForAll}
import Batch.{seqGen2batchGen, seq2batch}
import Buildables.{buildableBatch, buildableDStreamFromBatch}
import DStreamGen.arbDStream
  
/*
 * NOTE the use of the import alias org.scalatest.Inspectors.{forAll => testForAll} to
 * distinguish between ScalaTest forAll inspector used in matchers, and ScalaTest
 * forAll adapter for ScalaCheck 
 * */

object TLGenTest extends Properties("TLGen temporal logic generators properties") {
  property("""now() applied to a batch generator returns a dstream generator 
      with exactly one batch, and doesn't introduce new elements""") =
    forAll ("batch" |: arbitrary[Batch[Int]]) { batch : Batch[Int] =>
      // note here we are dropping some elements
      val g = TLGen.now(Gen.someOf(batch))
      forAll ("dstream" |: g) { dstream : DStream[Int] =>
        dstream should have length (1)
        dstream(0).length should be <= (batch.length) 
        testForAll (dstream(0)) { batch should contain (_)}
        true
      }
    }
  
  property("""now() applied to a constant batch generator returns a dstream generator
      with exactly that batch as the only batch""")  = 
    forAll ("batch" |: arbitrary[Batch[Int]]) { batch : Batch[Int] =>
      // using a constant generator
      val g = TLGen.now(batch : Batch[Int])
      forAll ("dstream" |: g) { dstream : DStream[Int] =>
        dstream should have length (1)
        dstream(0) should be (batch)
        true
      }
    }
  
  property("""nextB() returns a dstream generator that has exactly two batches, 
       the first one is emptyBatch, and the second one is its argument""") = 
    forAll ("batch" |: arbitrary[Batch[Int]]) { batch : Batch[Int] =>
      // using a constant generator
      val g = TLGen.nextB(batch : Batch[Int])
      forAll ("dstream" |: g) { dstream : DStream[Int] =>
        dstream should have length (2)
        dstream(0) should be (Batch.empty)
        dstream(1) should be (batch)
        true
      }
    }  
     
  property("""next() returns a dstream generator that has exactly 1 + the number
      of batches of its argument, the first one is emptyBatch, and the rest 
      are the batches generated by its argument""") = 
    forAll ("dstream " |: arbitrary[DStream[Int]])  { dstream : DStream[Int] =>
      // using a constant generator
      val g = TLGen.next(dstream)
      forAll ("nextDStream" |: g) { nextDStream : DStream[Int] =>
        nextDStream should have length (1 + dstream.length)
        nextDStream(0) should be (Batch.empty)
        nextDStream.slice(1, nextDStream.size) should be (dstream)
        true
      } 
    }
  
  // TODO: check untilB is not a weak until, i.e. the second generator always occurs
}